{-
Module:  MptcpAnalyzer.Commands.Plots.Live
Description :  Description
Maintainer  : matt
Portability : Linux
-}
module MptcpAnalyzer.Plots.Live
where

import qualified Data.Map as Map
import qualified Data.Text as T
import MptcpAnalyzer.ArtificialFields
import MptcpAnalyzer.Cache
import MptcpAnalyzer.Plots.Types
import MptcpAnalyzer.Prelude
import MptcpAnalyzer.Utils.Text
import Net.Tcp
import qualified Polysemy.Embed as P
import qualified Polysemy.Log as Log
import System.Process hiding (runCommand)
import Tshark.Live
import Tshark.Main

import Polysemy (Final, Members, Sem, runFinal)
import qualified Polysemy as P
import qualified Polysemy.Embed as P
import qualified Polysemy.IO as P
import qualified Polysemy.Internal as P
import Polysemy.Log (Log)
import qualified Polysemy.Log as Log
import Polysemy.Log.Colog (interpretLogStdout)
import qualified Polysemy.State as P
import Polysemy.Trace (trace)
import qualified Polysemy.Trace as P

-- import MptcpAnalyzer.Commands.Definitions as CMD
import Control.Monad.State (execStateT)
import Data.Maybe (fromMaybe)
import GHC.IO.Handle
import Pipes (runEffect)
import System.Exit
import System.IO (stdout)
import Tshark.Fields

-- (ArgsPlotLiveTcp connectionFilter mbFake mbConnectionRole ifname)
configureLivePlotTcp :: Members '[Log, Cache, P.Trace, P.Embed IO] r =>
  LivePlotTcpSettings -> Sem r LiveStatsTcp
configureLivePlotTcp (LivePlotTcpSettings connectionFilter mbFake mbConnectionRole ifname) = do
    let
      fields = Map.elems $ Map.map tfieldFullname baseFields

      -- stats/packetCount/Frame
      -- keeping it light for now
      destination = fromMaybe RoleServer mbConnectionRole
      initialLiveStats :: LiveStatsTcp = LiveStats mempty mempty 0 connectionFilter destination mempty False
      -- initialLiveStats :: LiveStatsTcp = LiveStats mempty 0 mempty
      toLoad = case mbFake of
        Just filename -> Right filename
        Nothing -> Left ifname

      --capture-comment
      tsharkPrefs = defaultTsharkPrefs {
        tsharkReadFilter = Just $ genReadFilterFromTcpConnection connectionFilter (Just destination)
        }
      (RawCommand bin genArgs) = generateCsvCommand fields toLoad tsharkPrefs
      -- args = genArgs ++ ["--capture-comment='Generated by mptcpanalyzer'"]
      args = genArgs ++ [ "-l"]
      createProc :: CreateProcess
      createProc = (proc bin args) {
            std_err = CreatePipe
            -- Inherit,
            , std_out = CreatePipe
            -- lets the child handle Ctrl-c
            , delegate_ctlc = True
          }

    Log.info $ "Looking at destination " <> tshow destination

    trace $ "Command run: " ++ show (RawCommand bin args)
    trace $ "Command run: " ++ showCommandForUser bin args
    -- Log.info $ "Starting " <> tshow bin <> tshow args
    ls <- P.embed $ startLivePlot initialLiveStats createProc
    pure ls

startLivePlot :: LiveStatsTcp -> CreateProcess -> IO LiveStatsTcp
-- startLivePlot createProc = do
--   -- hSetBuffering tmpFileHandle LineBuffering
--   -- hSeek tmpFileHandle AbsoluteSeek 0 >> T.hPutStrLn tmpFileHandle fieldHeader
--   -- mb_stdin_hdl, mb_stdout_hdl, mb_stderr_hdl, ph
--   (_, Just hout, Just herr, ph) <-  createProcess_ "error" createProc
--   -- threadId <- forkIO $
--   readTsharkOutputAndPlotIt hout herr
--   exitCode <- waitForProcess ph
startLivePlot initialLiveStats createProc = do
  (_, Just hout, Just herr, ph) <-  createProcess_ "error when creating process" createProc
  hSetBuffering stdout NoBuffering
  -- non blocking
  exitCode <- getProcessExitCode ph
  case exitCode of
    Just code -> putStrLn "Finished" >> pure initialLiveStats
    _ -> do
      -- hSetBuffering hout LineBuffering
      -- hSetBuffering herr NoBuffering
      putStrLn $ "Live stats (before): " ++ show (lsPackets initialLiveStats)
      liveStats <- execStateT (runEffect (tsharkLoop hout)) initialLiveStats
      putStrLn $ "Live stats (after): " ++ (T.unpack . showLiveStatsTcp) liveStats
      putStrLn $ "Live stats (after): " ++ show (lsPackets liveStats)
      -- blocking
      exitCode2 <- waitForProcess ph
      case exitCode2 of
        ExitSuccess -> putStrLn "Success" >> pure liveStats
        _  -> do
          putStrLn "hGetContents"
          hGetContents herr >>= putStrLn >> pure initialLiveStats
  -- putStrLn $ "final exitCode"


{- 
-}
monitorMptcpTraffic :: 
