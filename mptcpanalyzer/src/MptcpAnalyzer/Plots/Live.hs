{-
Module:  MptcpAnalyzer.Commands.Plots.Live
Description :  Description
Maintainer  : matt
Portability : Linux
-}
module MptcpAnalyzer.Plots.Live
where

import Net.Tcp
import Tshark.Main
import MptcpAnalyzer.ArtificialFields
import Tshark.Live
import qualified Data.Map as Map
import System.Process hiding (runCommand)
import qualified Data.Text as T
import qualified Polysemy.Log as Log
import qualified Polysemy.Embed as P

import MptcpAnalyzer.Commands.Definitions as CMD
import System.Exit

-- (ArgsPlotLiveTcp connectionFilter mbFake mbConnectionRole ifname)
configureLivePlotTcp :: LivePlotTcpSettings -> LiveStatsTcp
configureLivePlotTcp settings = do
        let
          fields = Map.elems $ Map.map tfieldFullname baseFields

          -- stats/packetCount/Frame
          -- keeping it light for now
          destination = fromMaybe RoleServer mbConnectionRole
          initialLiveStats :: LiveStatsTcp = LiveStats mempty mempty 0 connectionFilter destination mempty False
          -- initialLiveStats :: LiveStatsTcp = LiveStats mempty 0 mempty
          toLoad = case mbFake of
            Just filename -> Right filename
            Nothing -> Left ifname

          --capture-comment
          tsharkPrefs = defaultTsharkPrefs {
            tsharkReadFilter = Just $ genReadFilterFromTcpConnection connectionFilter (Just destination)
            }
          (RawCommand bin genArgs) = generateCsvCommand fields toLoad tsharkPrefs
          -- args = genArgs ++ ["--capture-comment='Generated by mptcpanalyzer'"]
          args = genArgs ++ [ "-l"]
          createProc :: CreateProcess
          createProc = (proc bin args) {
                std_err = CreatePipe
                -- Inherit,
                , std_out = CreatePipe
                -- lets the child handle Ctrl-c
                , delegate_ctlc = True
              }

        Log.info $ "Looking at destination " <> tshow destination

        trace $ "Command run: " ++ show (RawCommand bin args)
        trace $ "Command run: " ++ showCommandForUser bin args
        -- Log.info $ "Starting " <> tshow bin <> tshow args
        ls <- P.embed $ startLivePlot initialLiveStats createProc
        pure ls

startLivePlot :: LiveStatsTcp -> CreateProcess -> IO ()
-- startLivePlot createProc = do
--   -- hSetBuffering tmpFileHandle LineBuffering
--   -- hSeek tmpFileHandle AbsoluteSeek 0 >> T.hPutStrLn tmpFileHandle fieldHeader
--   -- mb_stdin_hdl, mb_stdout_hdl, mb_stderr_hdl, ph
--   (_, Just hout, Just herr, ph) <-  createProcess_ "error" createProc
--   -- threadId <- forkIO $
--   readTsharkOutputAndPlotIt hout herr
--   exitCode <- waitForProcess ph
startLivePlot initialLiveStats createProc = do
  (_, Just hout, Just herr, ph) <-  createProcess_ "error when creating process" createProc
  hSetBuffering stdout NoBuffering
  -- non blocking
  exitCode <- getProcessExitCode ph
  case exitCode of
    Just code -> putStrLn "Finished"
    _ -> do
      -- hSetBuffering hout LineBuffering
      -- hSetBuffering herr NoBuffering
      putStrLn $ "Live stats (before): " ++ show (lsPackets initialLiveStats)
      liveStats <- execStateT (runEffect (tsharkLoop hout)) initialLiveStats
      putStrLn $ "Live stats (after): " ++ (T.unpack . showLiveStatsTcp) liveStats
      putStrLn $ "Live stats (after): " ++ show (lsPackets liveStats)
      -- blocking
      exitCode2 <- waitForProcess ph
      case exitCode2 of
        ExitSuccess -> putStrLn "Success"
        _  -> do
          putStrLn "hGetContents"
          hGetContents herr >>= putStrLn
  putStrLn $ "final exitCode"

